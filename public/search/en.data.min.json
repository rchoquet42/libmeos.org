[{"id":0,"href":"/movingfeaturesformats/","title":"Movingfeaturesformats","parent":"LibMEOS","content":"Temporal types can be represented in the following formats:\nWell-Known Text (WKT) Moving-Features JSON (MF-JSON) Well-Known Binary (WKB) "},{"id":1,"href":"/movingfeaturesformats/mfjson/","title":"Moving Features JSON (MF-JSON)","parent":"Movingfeaturesformats","content":"“Moving Features JSON” is a standard for encoding moving features in JSON. By using MF-JSON, rather than some other arbitrary scheme, you maximize the interoperability of your JSON output. MF-JSON is an Open Geospatial Consortium standard, which extends the GeoJSON standard.\nExamples {\u0026ldquo;type\u0026rdquo;:\u0026ldquo;MovingBoolean\u0026rdquo;,\u0026ldquo;values\u0026rdquo;:true,\u0026ldquo;datetimes\u0026rdquo;:\u0026ldquo;2000-01-01T00:00:00\u0026rdquo;,\u0026ldquo;interpolations\u0026rdquo;:[\u0026ldquo;Discrete\u0026rdquo;]} {\u0026ldquo;type\u0026rdquo;:\u0026ldquo;MovingInteger\u0026rdquo;,\u0026ldquo;values\u0026rdquo;:2,\u0026ldquo;datetimes\u0026rdquo;:\u0026ldquo;2000-01-01T00:00:00\u0026rdquo;,\u0026ldquo;interpolations\u0026rdquo;:[\u0026ldquo;Discrete\u0026rdquo;]} {\u0026ldquo;type\u0026rdquo;:\u0026ldquo;MovingFloat\u0026rdquo;,\u0026ldquo;values\u0026rdquo;:2.5,\u0026ldquo;datetimes\u0026rdquo;:\u0026ldquo;2000-01-01T00:00:00\u0026rdquo;,\u0026ldquo;interpolations\u0026rdquo;:[\u0026ldquo;Discrete\u0026rdquo;]} {\u0026ldquo;type\u0026rdquo;:\u0026ldquo;MovingText\u0026rdquo;,\u0026ldquo;values\u0026rdquo;:\u0026ldquo;walking\u0026rdquo;,\u0026ldquo;datetimes\u0026rdquo;:\u0026ldquo;2000-01-01T00:00:00\u0026rdquo;,\u0026ldquo;interpolations\u0026rdquo;:[\u0026ldquo;Discrete\u0026rdquo;]} {\u0026ldquo;type\u0026rdquo;:\u0026ldquo;MovingPoint\u0026rdquo;,\u0026ldquo;coordinates\u0026rdquo;:[1,1],\u0026ldquo;datetimes\u0026rdquo;:\u0026ldquo;2000-01-01T00:00:00\u0026rdquo;,\u0026ldquo;interpolations\u0026rdquo;:[\u0026ldquo;Discrete\u0026rdquo;]} {\u0026ldquo;type\u0026rdquo;:\u0026ldquo;MovingPoint\u0026rdquo;,\u0026ldquo;crs\u0026rdquo;:{\u0026ldquo;type\u0026rdquo;:\u0026ldquo;name\u0026rdquo;,\u0026ldquo;properties\u0026rdquo;:{\u0026ldquo;name\u0026rdquo;:\u0026ldquo;EPSG:5676\u0026rdquo;}},\u0026ldquo;coordinates\u0026rdquo;:[1,1],\u0026ldquo;datetimes\u0026rdquo;:\u0026ldquo;2000-01-01T00:00:00\u0026rdquo;,\u0026ldquo;interpolations\u0026rdquo;:[\u0026ldquo;Discrete\u0026rdquo;]} {\u0026ldquo;type\u0026rdquo;:\u0026ldquo;MovingInteger\u0026rdquo;,\u0026ldquo;values\u0026rdquo;:[1,2],\u0026ldquo;datetimes\u0026rdquo;:[\u0026ldquo;2022-01-01T08:00:00\u0026rdquo;,\u0026ldquo;2022-01-01T09:00:00\u0026rdquo;],\u0026ldquo;interpolations\u0026rdquo;:[\u0026ldquo;Discrete\u0026rdquo;]} {\u0026ldquo;type\u0026rdquo;:\u0026ldquo;MovingPoint\u0026rdquo;,\u0026ldquo;coordinates\u0026rdquo;:[[1,1],[2,2]],\u0026ldquo;datetimes\u0026rdquo;:[\u0026ldquo;2022-01-01T08:00:00\u0026rdquo;,\u0026ldquo;2022-01-01T09:00:00\u0026rdquo;],\u0026ldquo;lower_inc\u0026rdquo;:true,\u0026ldquo;upper_inc\u0026rdquo;:true,\u0026ldquo;interpolations\u0026rdquo;:[\u0026ldquo;Linear\u0026rdquo;]} {\u0026ldquo;type\u0026rdquo;:\u0026ldquo;MovingText\u0026rdquo;,\u0026ldquo;sequences\u0026rdquo;:[{\u0026ldquo;values\u0026rdquo;:[\u0026ldquo;driving\u0026rdquo;,\u0026ldquo;driving\u0026rdquo;],\u0026ldquo;datetimes\u0026rdquo;:[\u0026ldquo;2022-01-01T08:00:00\u0026rdquo;,\u0026ldquo;2022-01-01T09:00:00\u0026rdquo;],\u0026ldquo;lower_inc\u0026rdquo;:true,\u0026ldquo;upper_inc\u0026rdquo;:true},{\u0026ldquo;values\u0026rdquo;:[\u0026ldquo;walking\u0026rdquo;,\u0026ldquo;walking\u0026rdquo;],\u0026ldquo;datetimes\u0026rdquo;:[\u0026ldquo;2022-01-01T10:00:00\u0026rdquo;,\u0026ldquo;2022-01-01T11:00:00\u0026rdquo;],\u0026ldquo;lower_inc\u0026rdquo;:true,\u0026ldquo;upper_inc\u0026rdquo;:true}],\u0026ldquo;interpolations\u0026rdquo;:[\u0026ldquo;Stepwise\u0026rdquo;]} {\u0026ldquo;type\u0026rdquo;:\u0026ldquo;MovingPoint\u0026rdquo;,\u0026ldquo;sequences\u0026rdquo;:[{\u0026ldquo;coordinates\u0026rdquo;:[[1,1],[2,2]],\u0026ldquo;datetimes\u0026rdquo;:[\u0026ldquo;2022-01-01T08:00:00\u0026rdquo;,\u0026ldquo;2022-01-01T09:00:00\u0026rdquo;],\u0026ldquo;lower_inc\u0026rdquo;:true,\u0026ldquo;upper_inc\u0026rdquo;:true},{\u0026ldquo;coordinates\u0026rdquo;:[[3,3],[3,3]],\u0026ldquo;datetimes\u0026rdquo;:[\u0026ldquo;2022-01-01T10:00:00\u0026rdquo;,\u0026ldquo;2022-01-01T11:00:00\u0026rdquo;],\u0026ldquo;lower_inc\u0026rdquo;:true,\u0026ldquo;upper_inc\u0026rdquo;:true}],\u0026ldquo;interpolations\u0026rdquo;:[\u0026ldquo;Linear\u0026rdquo;]} "},{"id":2,"href":"/movingfeaturesformats/wkb/","title":"Well-Known Binary (WKB)","parent":"Movingfeaturesformats","content":"“Well-known binary” is a scheme for writing moving features into a platform-independent array of bytes, usually for transport between systems or between programs. By using WKB, systems can avoid exposing their particular internal implementation of geometry storage, for greater overall interoperability. It is an extension of the scheme for writing a simple features geometry into a platform-independent array of bytes.\nData Types The WKB specification uses five basic types common to most typed languages: an unsigned byte, a 4-byte unsigned integer, an 8-byte unsigned integer, an 8-byte IEEE double, and a string of characters.\n// byte : 1 byte // uint32 : 32 bit unsigned integer (4 bytes) // uint64 : 64 bit unsigned integer (8 bytes) // double : double precision number (8 bytes) // string : string of characters (variable number of bytes) Byte Order In order to allow portability between systems with difference architectures, the representation of those types is conditioned by the wkbByteOrder.\nenum wkbByteOrder { wkbXDR = 0, // Big Endian wkbNDR = 1 // Little Endian }; A “little endian” integer has the least-significant bytes first, hence “little”. For example, the number 1, encoded in little- and big- endian:\n# Little endian 01 00 00 00 # Big endian 00 00 00 01 In practice this means that almost all WKB is encoded little endian, since most modern processors are little endian, but the existence of the wkbByteOrder allows WKB to transport geometry easily between systems of different endianness.\n"},{"id":3,"href":"/movingfeaturesformats/wkt/","title":"Well-Known Text (WKT)","parent":"Movingfeaturesformats","content":"“Well-known text” is a scheme for writing moving features into a standard text string. It is an extension of the scheme for writing a simple features geometry into a standard text string.\nWKT BNF \u0026lt;at\u0026gt; ::= @ \u0026lt;comma\u0026gt; ::= , \u0026lt;equal\u0026gt; ::= = \u0026lt;semicolon\u0026gt; ::= ; \u0026lt;left paren\u0026gt; ::= ( \u0026lt;right paren\u0026gt; ::= ) \u0026lt;left bracket\u0026gt; ::= [ \u0026lt;right bracket\u0026gt; ::= ] \u0026lt;left brace\u0026gt; ::= { \u0026lt;right brace\u0026gt; ::= } \u0026lt;srid\u0026gt; ::= SRID \u0026lt;z\u0026gt; ::= Z \u0026lt;b\u0026gt; ::= \u0026lt;boolean\u0026gt; \u0026lt;f\u0026gt; ::= \u0026lt;float\u0026gt; \u0026lt;i\u0026gt; ::= \u0026lt;integer\u0026gt; \u0026lt;s\u0026gt; ::= \u0026lt;string\u0026gt; \u0026lt;t\u0026gt; ::= \u0026lt;timestamp\u0026gt; \u0026lt;bool representation\u0026gt; ::= \u0026lt;b\u0026gt; \u0026lt;int representation\u0026gt; ::= \u0026lt;i\u0026gt; \u0026lt;float representation\u0026gt; ::= \u0026lt;f\u0026gt; \u0026lt;text representation\u0026gt; ::= \u0026lt;s\u0026gt; \u0026lt;x coord\u0026gt; ::= \u0026lt;f\u0026gt; \u0026lt;y coord\u0026gt; ::= \u0026lt;f\u0026gt; \u0026lt;z coord\u0026gt; ::= \u0026lt;f\u0026gt; \u0026lt;coords\u0026gt; ::= \u0026lt;x coord\u0026gt; \u0026lt;y coord\u0026gt; [ \u0026lt;z coord\u0026gt; ] \u0026lt;srid representation\u0026gt; ::= \u0026lt;srid\u0026gt; \u0026lt;equal\u0026gt; \u0026lt;i\u0026gt; \u0026lt;semicolon\u0026gt; \u0026lt;point representation\u0026gt; ::= [ \u0026lt;srid\u0026gt; ] POINT [ \u0026lt;z\u0026gt; ] \u0026lt;left paren\u0026gt; \u0026lt;coords\u0026gt; \u0026lt;right paren\u0026gt; \u0026lt;base representation\u0026gt; ::= \u0026lt;bool representation\u0026gt; | \u0026lt;int representation\u0026gt; | \u0026lt;float representation\u0026gt; | \u0026lt;text representation\u0026gt; | \u0026lt;point representation\u0026gt; | \u0026lt;tinstant\u0026gt; ::= \u0026lt;base representation\u0026gt; \u0026lt;at\u0026gt; \u0026lt;t\u0026gt; \u0026lt;tinstant set\u0026gt; ::= \u0026lt;left brace\u0026gt; \u0026lt;tinstant\u0026gt; {\u0026lt;comma\u0026gt; \u0026lt;tinstant\u0026gt;} ... \u0026lt;right brace\u0026gt; \u0026lt;tsequence set\u0026gt; ::= \u0026lt;left bracket\u0026gt; \u0026lt;tinstant\u0026gt; {\u0026lt;comma\u0026gt; \u0026lt;tinstant\u0026gt;} ... \u0026lt;right bracket\u0026gt; \u0026lt;tsequence set\u0026gt; ::= \u0026lt;left brace\u0026gt; \u0026lt;tsequence\u0026gt; {\u0026lt;comma\u0026gt; \u0026lt;tsequence\u0026gt;} ... \u0026lt;right brace\u0026gt; \u0026lt;wkt representation\u0026gt; ::= \u0026lt;tinstant\u0026gt; | \u0026lt;tinstant set\u0026gt; | \u0026lt;tsequence\u0026gt; | \u0026lt;tsequence set\u0026gt; Writing WKT Because WKT is a decimal text output, it will never be able to exactly represent the underlying machine representation of the coordinates. In general, WKT is used for display to humans, or for transport when exact coordinate representation is not required (some web applications).\nAccordingly, MEOS allows you to customize the coordinate precision and rounding behaviour, as well as the dimensionality of WKT output.\n/* Read an instant */ const char *wkt_in = \u0026#34;Point(1 1 1,2 2 2)@2022-01-01\u0026#34;; TInstant *inst = tgeompoint_from_text(inst_str); /* Generate the output WKT */ * The first argument sets the number places after the decimal to output in WKT. Default 16. * The second argument sets the number of dimension to output in WKT. Default is as in the data. */ unsigned char *wkt = tgeompoint_as_text(inst, 6, 2); /* do something ... */ /* Free the allocated memory */ free(wkt_in); free(wkt_out); free(inst); Examples true@2022-01-01 08:00:00 1@2022-01-01 08:00:00 2.5@2022-01-01 08:00:00 walking@2022-01-01 08:00:00 POINT(0 0)@2022-01-01 08:00:00 SRID=5676;Point(1 1)@2022-01-01 08:00:00 {1@2022-01-01 08:00:00, 2@2022-01-01 09:00:00} [POINT(1 1)@2022-01-01 08:00:00, POINT(2 2)@2022-01-01 09:00:00] {[driving@2022-01-01 08:00:00, driving@2022-01-01 09:00:00], [walking@2022-01-01 10:00:00, walking@2022-01-01 11:00:00]} {[POINT(1 1)@2022-01-01 08:00:00, POINT(2 2)@2022-01-01 09:00:00], [POINT(3 3)@2022-01-01 10:00:00, POINT(3 3)@2022-01-01 11:00:00]} "},{"id":4,"href":"/documentation/datamodel/","title":"Data model","parent":"Documentation","content":"MEOS provides temporal types, which represent the evolution on time of values of some element type, called the base type of the temporal type. For instance, temporal integers may be used to represent the evolution on time of the gear used by a moving car. In this case, the data type is temporal integer and the base type is integer. Similarly, a temporal float may be used to represent the evolution on time of the temperature of the interior of a car. As another example, a temporal point may be used to represent the evolution on time of the location of a car, as reported by GPS devices. Temporal types are useful because representing values that evolve in time is essential in many applications, especially in mobility applications. Furthermore, the operators on the base types (such as arithmetic operators for integers and floats, spatial relationships and distance for geometries) can be intuitively generalized when the values evolve in time.\nMEOS has six built-in temporal types, namely tbool, tint, tfloat, ttext, tgeompoint, and tgeogpoint, which are, respectively, based on the alphanumeric base types bool (a boolean value), int (a 4-byte integer number), float (an 8-byte floating point number), and text (a string of characters of variable size), as well as the geospatial base types geometry, and geography borrowed from PostGIS and restricted to 2D or 3D points with Z dimension.\nThe interpolation of a temporal value states how the value evolves between successive instants. The interpolation is stepwise when the value remains constant between two successive instants. For example, the gear used by a moving car may be represented with a temporal integer, which indicates that its value is constant between two time instants. On the other hand, the interpolation is linear when the value evolves linearly between two successive instants. For example, the temperature inside a car may be represented with a temporal float, which indicates that the values are known at the two time instants but continuously evolve between them. Similarly, the location of a vehicule may be represented by a temporal point where the location between two consecutive GPS readings is obtained by linear interpolation. Temporal types based on discrete base types, that is the tbool, tint, or ttext evolve necesssarily in a stepwise manner. On the other hand, temporal types based on continuous base types, that is tfloat, tgeompoint, or tgeogpoint may evolve in a stepwise or linear manner.\nThe subtype of a temporal value states the temporal extent at which the evolution of values is recorded. Temporal values come in four subtypes, namely, instant, instant set, sequence, and sequence set.\nA temporal value of instant subtype (briefly, an instant value) represents the value at a time instant, for example\n'17@2018-01-01 08:00:00'\nA temporal value of instant set subtype (briefly, an instant set value) represents the evolution of the value at a set of time instants, where the values between these instants are unknown. An example is as follows:\n'{17@2018-01-01 08:00:00, 17.5@2018-01-01 08:05:00, 18@2018-01-01 08:10:00}'\nA temporal value of sequence subtype (briefly, a sequence value) represents the evolution of the value during a sequence of time instants, where the values between these instants are interpolated using either a stepwise or a linear function (see below). An example is as follows:\n'(10@2018-01-01 08:00:00, 20@2018-01-01 08:05:00, 15@2018-01-01 08:10:00]'\nAs can be seen, a sequence value has a lower and an upper bound that can be inclusive (represented by ‘[’ and ‘]’) or exclusive (represented by ‘(’ and ‘)’). A sequence value with a single instant such as '[10@2018-01-01 08:00:00]' is called an instantaneous sequence. In that case, both bounds must be inclusive.\nThe value of a temporal sequence is interpreted by assuming that the period of time defined by every pair of consecutive values v1@t1 and v2@t2 is lower inclusive and upper exclusive, unless they are the first or the last instants of the sequence and in that case the bounds of the whole sequence apply. Furthermore, the value taken by the temporal sequence between two consecutive instants depends on whether the interpolation is stepwise or linear. For example, the temporal sequence above\n'(10@2018-01-01 08:00:00, 20@2018-01-01 08:05:00, 15@2018-01-01 08:10:00]'\nrepresents that the value evolves from 10 to 20 during (2018-01-01 08:00:00, 2018-01-01 08:05:00) and evolves from 20 to 15 during [2018-01-01 08:05:00,2018-01-01 08:10:00]. On the other hand, the temporal sequence\n'Interp=Stepwise;(10@2018-01-01 08:00:00, 20@2018-01-01 08:05:00, 15@2018-01-01 08:10:00]'\nrepresents that the value is 10 during (2018-01-01 08:00:00, 2018-01-01 08:05:00), 20 during [2018-01-01 08:05:00,2018-01-01 08:10:00), and 15 at the end instant 2018-01-01 08:10:00.\nFinally, a temporal value of sequence set subtype (briefly, a sequence set value) represents the evolution of the value at a set of sequences, where the values between these sequences are unknown. An example is as follows:\n{[17@2018-01-01 08:00:00, 17.5@2018-01-01 08:05:00], [18@2018-01-01 08:10:00, 18@2018-01-01 08:15:00]}\nEach temporal type is associated to another type, referred to as its bounding box, which represent its extent in the value and/or the time dimension. The bounding box of the various temporal types are as follows:\nThe period type for the tbool and ttext types, where only the temporal extent is considered. A tbox (temporal box) type for the tint and tfloat types, where the value extent is defined in the X dimension and the temporal extent in the T dimension. A stbox (spatiotemporal box) type for the tgeompoint and tgeogpoint types, where the spatial extent is defined in the X, Y, and Z dimensions (where the Z dimension is optional), and the temporal extent in the T dimension. A rich set of functions and operators is available to perform various operations on temporal types.\n"},{"id":5,"href":"/documentation/","title":"Documentation","parent":"LibMEOS","content":""},{"id":6,"href":"/documentation/developer/","title":"Developer's Documentation","parent":"Documentation","content":"The developer\u0026rsquo;s documentation is available at docs.libmeos.org\nAlternatively, you can generate the English developer\u0026rsquo;s documentation in HTML format from the source:\ngit clone --branch develop https://github.com/MobilityDB/MobilityDB MobilityDB mkdir MobilityDB/build cd MobilityDB/build cmake -DMEOS=on -DDOC_DEV=on .. make -j make doc_dev The resulting HTML documentation will be generated in the doxygen directory of the build directory.\n"},{"id":7,"href":"/project/","title":"Project","parent":"LibMEOS","content":"MEOS (Mobility Engine, Open Source) is a C library which makes it easy to work with temporal and spatio-temporal data. It is based on MobilityDB\u0026rsquo;s data types and functions.\nMobilityDB extends the ISO 19141:2008 standard (Geographic information — Schema for moving features) for representing the change of non-spatial attributes of features, which is not covered by the standard. It also takes into account the fact that when collecting mobility data it is necessary to represent “temporal gaps”, that is, for some period of time no observations were collected, for instance, due to GPS signal loss.\nMEOS is heavily inspired by a similar library called GEOS (Geometry Engine, Open Source) — hence the name. A first version of the MEOS library written in C++ has been proposed by Krishna Chaitanya Bommakanti. However, due to the fact that MEOS codebase is actually a subset of MobilityDB codebase, which is almost entire written in C, this version of the library allows us to evolve both programming environments simultaneously.\n"},{"id":8,"href":"/project/licence/","title":"Licence","parent":"Project","content":"MEOS is open source software available under the terms of the PostgreSQL license\n"},{"id":9,"href":"/","title":"LibMEOS","parent":"","content":" Disclaimer: The MEOS library and this website are in development! MEOS (Mobility Engine, Open Source) is a C library which makes it easy to work with temporal and spatio-temporal data. It is based on MobilityDB\u0026rsquo;s data types and functions.\nMobilityDB extends the ISO 19141:2008 standard (Geographic information — Schema for moving features) for representing the change of non-spatial attributes of features, which is not covered by the standard. It also takes into account the fact that when collecting mobility data it is necessary to represent “temporal gaps”, that is, for some period of time no observations were collected, for instance, due to GPS signal loss.\nMEOS is heavily inspired by a similar library called GEOS (Geometry Engine, Open Source) — hence the name. A first version of the MEOS library written in C++ has been proposed by Krishna Chaitanya Bommakanti. However, due to the fact that MEOS codebase is actually a subset of MobilityDB codebase, which is almost entire written in C, this version of the library allows us to evolve both programming environments simultaneously.\n"},{"id":10,"href":"/tags/","title":"Tags","parent":"LibMEOS","content":""}]